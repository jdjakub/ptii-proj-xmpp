Implementation

---< PINK BOOK >---
This chapter should describe what was actually produced: programs written, hardware built, theory developed.

Any design strategies that looked ahead to the testing stage might profitably be referred to (that goddamn "professional approach" again).

Descriptions of programs may include fragments of high-level code. But large chunks of code are usually best left to appendices or omitted altogether. Analogous advice applies to circuit diagrams. Not that I have any of those.

Draw attention to the parts of the work which are not your own (true: unix, thread, angstrom, rresult, base64, bigstring). Making effective use of powerful tools and pre-existing code is often laudable, and will count to your credit if properly reported.

It should not be necessary to give a day-by-day account of the progress of the work, but - major milestones may sometimes be highlighted with advantage...

Implementation is worth 40% of the marks. My implementation is pretty good, considering. However, it doesn't make effective use of the module system or interfaces; it architects per-client logic differently between client and server; the XML tree vs text distinction ought to have been made in the type system, currently it sticks out like the unnecessary cruft it is; buffering has been a nightmare and is likely sub-par. Still: parsing and flow handled well, much advantageous use of combinators and monads.
---</ PINK BOOK >---

I've implemented: server, client for testing!!. Both depend on Xmpp and Xml modules.
As the objective of this project was to build a server, I developed a server program (server.ml). I used the Psi client software to help develop the server, but for later testing a more automatable client was needed. For this reason, I also developed a basic XMPP client controller (client.ml).

xml.ml:
XML is represented in three ways: as text, as low-level 'Raw' XML, and as high-level xml_node. The Xml module provides utilities work working with these representations.

XML as text is suitable only for human comprehension; computationally, being a long unstructured block of bytes, it is unsuitable for computer processing. XMPP, though, is built around sending and receiving XML via text, so the server needs to analyse incoming XML and output XML text to clients. The Xml.P module contains Angstrom parsers for XML syntax, producing the `literal' abstract representation defined in Xml.P.Raw. Functions for converting this back into text, for output purposes, also live in Xml.P.Raw.

The main Angstrom parser is P.tree, which converts nested open/close tags and embedded text into a Raw.Branch node, or Raw.Text if the whole thing consists of just text. This suffices for most of XMPP, but there are some situations that do not involve fully completed trees. For example, setting up the client-server XML stream involves only the opening tag of the stream element; likewise, terminating the stream requires the closing tag. Thus, tag_open and tag_close are provided. In addition, before opening the stream, an XML declaration <?xml version="1.0"?> is needed, which uses slightly different syntax to XML tags. Since this syntax does not appear anywhere else, there is a custom xml_decl parser for this purpose.

These parsers are all implemented in terms of smaller named parsers, combined using the Angstrom parser combinators. For example, tag_open is implemented this way:

let tag_open =
  tok_langle *> qual_name >>= fun (ns,id) ->
    lift2 (fun attrs _ -> Raw.Branch ((ns,id,attrs),[]))
      (many attr_val)
      tok_rangle

This is read as: "Accept the token <, then a qualified name, then zero or more attribute-value pairs, then the token >; combine the qualified name and the attributes into a Branch node with no children". To elaborate slightly: tok_langle = lex (char '<'), tok_colon = lex (char ':'), and so on, where lex skips whitespace.

A note on namespaces:
Namespaces are a way to organise tags and avoid naming conflicts in XML. Tags are qualified, explicitly or implicitly, by a namespace, typically a long string. Because this is cumbersome to work with, a shorthand for the tag's namespace is prefixed onto it. The association between a prefix and the namespace it represents is defined by an (ab)use of the XML attribute system: the attribute xmlns:foo="bar" is treated specially as saying that the prefix foo represents the namespace bar. Tags that are not explicitly prefixed use the default prefix, signified by xmlns="bar".

Both explicit and default prefixes are used throughout XMPP. Requirements such as ``the first element must be the <stream> element'' demand consideration of ``in which namespace?''. Initially, one would suppose that the particular prefix used on a particular element does not matter. For instance, the body element of HTML could be written <html:body> (as long as the html prefix referred to the HTML namespace), <body> (provided HTML was the default namespace), or even <quux:body> (if quux referred to the HTML namespace). However, XMPP provides at least one exception to this: the initial <stream> element needs to use the stream: prefix, for unknown reasons. So, a distinction between namespaces and their prefixes was preserved at some level of the system. However, in the other 99% of cases, I considered it sufficient to place constraints only on the namespace and tag, and this is reflected in most functions taking namespace parameters.

As mentioned, the Raw module contains the `literal' abstract XML representation that these parsers target. Consider

<foo:error type="fatal" xmlns:foo="bar">
  <a></a>
  <b></b>
  Sample text
</foo:error>

The parent node has a qualified tag foo:error, along with a list of attributes. Each attribute conceptually consists of a prefix, name and value. The prefix might be empty, such as the case of type="fatal". The abstract representation makes all these explicit, representing attributes as pairs of qualified names and values. type="fatal" and xmlns:foo="bar" become the list [ (("", "type"), "fatal"); (("xmlns", "foo"), "bar") ].

Note the `literal' interpretation of the attribute list as an actual OCaml list. Technically, the order of XML attributes does not matter, but it is simpler to use a list at this level. Also, the attribute system in XML is (ab)used for the purpose of defining namespaces: an `attribute' like (("xmlns", "foo"), "bar") is not really an attribute at all, but specifies that the prefix foo represents the namespace bar. In addition, any (("", "xmlns"), "bar") attribute represents the default namespace. These special considerations are not handled in this representation, and it sees them just as normal attributes.

The above XML source would parse into the following Raw.xml:

Branch ( ("foo", "error", [ (("", "type"), "fatal"); (("xmlns", "foo"), "bar") ]) , [
  Branch ( ("", "a", []) , []) ;
  Branch ( ("", "b", []) , []) ;
  Text "Sample text" ;
] )

The higher-level representation, xml_node, exists for situations where Raw's data structures become unwieldy. It is defined as follows:

type xml_node =
| Text of lang * string
| Xml of {
  tag    : qname;
  attr   : string -> string option;
  attr_full : qname -> string option;
  namespace : string -> string option;
  lang  : lang;
  child : xml_node list;
  orig  : P.Raw.xml;
}

The main improvement is the use of an opaque attribute lookup function, rather than an explicit data structure. attr_full takes a qualified name, but since most attributes do not have a namespace prefix, the more convenient attr is also provided. attr is implemented as calling attr_full with an empty namespace prefix.

One consideration with namespaces is that prefix-namespace mappings are inherited to child nodes of their declaration site. xml_node incorporates this functionality into the namespace function. It finds the namespace associated with a prefix by delegating to the namespace function of the parent node if unsuccessful.

attr, attr_full and namespace all internally use the standard library's Map structure, being more appropriate for lookup than lists; lists require a linear scan to locate a mapping, and a full scan of the list to determine its absence, whereas Map provides logarithmic-time lookup.

An xml_node is normally constructed from an original Raw.xml structure, and it is useful to keep this information for output purposes. It is stored in the orig field.

The text-to-Raw parsers solve the problem of structuring XML and detecting syntax errors; after all, not all text is valid XML. However, XMPP is a protocol over XML and hence imposes a second level of `syntax' on top of this. So, in a similar way, not all valid XML is valid XMPP. But this does not entail further structuring of the XML; rather, it mainly involves checking that certain tags or attributes are present, and extracting values of attributes or embedded text nodes --- this problem is one of `pattern matching' rather than parsing. OCaml's built-in pattern matching proved not to be suitable for this purpose, so I went down the route of parsers and combinators modelled after Angstrom.

Unlike Angstrom's parsers, which are designed to be fairly orthogonal, fundamental building blocks of more complex parsers, mine are deliberately special-purpose. I went with whatever would be useful to write readable code, without necessarily being exhaustive in the range of behaviours achievable by combining them.

I viewed a `matcher' as a function accepting an xml_node and returning a Result value. Composition of matchers was then to involve both composition of functions, and composition of Result values. The resulting library could be seen as a fusion of the Function and Result monads. [should be footnote?] Application of a matcher to an xml_node is simple function application.

The matchers live in the Xml.Check module. The main ones are tag / qtag, attr / attr_opt, attv, child / children, orig and text.

tag "message" succeeds if the node has the "message" tag (irrespective of namespace considerations)
qtag functions like tag, but takes a namespace prefix to also check
attr "id" results in the value of the id attribute if it exists
attv "id" "1234" succeeds if the id attribute exists and is equal to 1234
attr_opt is like attr but does not fail, instead resulting in Some value or None
child gives the first child of the node if it exists
children gives a list of the node's children (possibly the empty list, so this one also never fails)
orig results in the low-level Raw representation from which the xml_node was obtained
text gives the text string of a Text node

Output functions designed for convenience of notation; get around compulsory parentheses for data ctors by using functions; provide common defaults via different functions; namespace automagic. Large input/output asymmetry; output to Raw is fine and natural. Input to Raw: very cumbersome to pattern match, etc. Lists of attrs: quick-and-dirty implementation of key[attr]-value map. Superfluous order, linear scan to retrieve attribute value, full scan to determine absence of attribute. Namespace short/long/default forms not handled, nor inherited / nested namespaces; qname cruft needed approximately 1% of the time. So: enter xml_node; Text augmented with lang... and attr is a function (using Map struct), namespace is a function, etc. Converting Raw to xml_node handles nesting of namespaces.

xml_node enables higher-level combinators (the Check module):
tag "message" succeeds if the node has the "message" tag (irrespective of namespace considerations)
qtag functions like tag, but takes a namespace prefix to also check
attr "id" results in the value of the id attribute if it exists
attv "id" "1234" succeeds if the id attribute exists and is equal to 1234
attr_opt is like attr but does not fail, instead resulting in Some value or None
child gives the first child of the node if it exists
children gives a list of the node's children (possibly the empty list, so this one also never fails)
orig results in the low-level Raw representation from which the xml_node was obtained
text gives the text string of a Text node

xml.ml also contains the hack-y expect and buffered_expect.

xmpp.ml:
namespace defs
Roster module
underpopulated Stanza module (containing Iq only)

server.ml:
Dispatch machinery
sv_start driver
per_client; XMPP handshake

The server program uses a simple `driver' to spawn off a thread each time a client connects. The function sv_start () simply performs Unix.establish_server on the local loopback address, passing in the function per_client.

When Unix.establish_server accepts a client connection, it opens a read and a write channel and passes them to per_client. The XMPP protocol then follows in two broad stages, setup and service. Setup involves handshaking with the client, performing authentication and resource binding, and the initial presence. Service consists of responding to client requests and delivering messages to the client.

All of these stages make use of the Result monad to deal with errors. Errors that occur during handshaking abort the protocol, as do fundamental errors during service (such as malformed XML). The service stage also deals with certain recoverable errors in individual stanzas, such as requests for unimplemented functionality.

Setup



client.ml:
object rationale
symmetric duplication of server.ml :/

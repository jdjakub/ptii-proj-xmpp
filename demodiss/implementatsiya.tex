\chapter{Implementation}
As the objective of this project was to build a server, I developed a server program (\code{server.ml}). I used the Psi client software to help develop the server, but for later testing a more automatable client was needed. For this reason, I also developed a basic XMPP client controller (\code{client.ml}).
These both make heavy use of the \code{Xml} and \code{Xmpp} modules.

\section{The \code{Xml} module}
XML is central to XMPP. In my code, it comes in three main forms: as text, as low-level `Raw' XML, and as high-level \code{xml_node}. The \code{Xml} module provides utilities for working with these representations.

First, a note on terminology. XML is a notation for hierarchical trees, and an XML node \footnote{Technically, there are also text nodes: as XML was designed as a markup language, any point in the tree can be made up of text, or `content'. This case is obviously handled, but does not have any terminological considerations.} has the form
\begin{lstlisting}[language=xml]
<prefix:tag pre1:attr1="value1" pre2:attr2="value2" ... pren:attrn="valuen" >
   ... children ...
</prefix:tag>
\end{lstlisting} where \code{attr}\(i\) are the node's attributes. Most of the time, prefixes are absent from attributes, but they are used in a couple of important cases outlined below. I call the combination of prefix and identifier a \emph{qualified name}. This way, a node can be seen as
\begin{lstlisting}[language=xml]
<qname qname1="value1" qname2="value2" ... qnamen="valuen" >
  ...
</qname>
\end{lstlisting}

Namespaces are a way to organise tags and avoid naming conflicts in XML; each tag is qualified by a namespace. Namespaces are typically long strings, and it would be cumbersome to work with XML where every single tag had such a namespace concatenated onto it. Instead, a shorthand for the namespace is prefixed onto tags. The association between a prefix and the namespace it represents is defined by an (ab)use of the XML attribute system: the `attribute' \code{xmlns:foo="bar"} is treated specially as saying that the prefix \code{foo} represents the namespace \code{bar}. A tag can in fact forego a prefix, in which case it is considered to use the default prefix, signified by \code{xmlns="bar"}. These associations are local to the node in the tree and are inherited by its children. There may be other uses of the \code{xmlns:} prefix, but I considered namespace definition as the only aspect relevant to this project.

Both explicit and default prefixes are used throughout XMPP. When starting out, I assumed that the particular prefix used on some element would not matter. For instance, the \code{<body>} element of HTML could be written \code{<html:body>} (as long as the \code{html} prefix referred to the HTML namespace), \code{<body>} (provided HTML was the default namespace), or even \code{<quux:body>} (if quux referred to the HTML namespace). However, XMPP provides at least one exception to this: the initial \code{<stream>} element needs to use the \code{stream:} prefix. So, a distinction between namespaces and their prefixes was preserved at some level of the system. However, in the other 99\% of cases, I considered it sufficient to place constraints only on the namespace and tag, hence why the XML checking functions are prefix-agnostic.

XML-as-text is suitable only for human comprehension; computationally, being a long unstructured block of bytes, it is unsuitable for computer processing. XMPP, though, is built around sending and receiving XML via text, so the ability to parse incoming XML and output XML text was fundamental. The Xml.P module contains Angstrom parsers for XML syntax, producing a `literal' abstract representation defined in \code{Xml.P.Raw}. Functions for converting this back into text, for output purposes, also live in \code{Xml.P.Raw}.

The main Angstrom parser is \code{tree}, which converts nested opening/closing tags and embedded text into a \code{Raw.Branch} node, or \code{Raw.Text} if the whole thing consists of just text. This suffices for most of XMPP, but there are some situations that do not involve fully completed trees. For example, setting up the client-server XML stream involves only the opening tag of the \code{<stream>} element; likewise, terminating the stream requires the closing tag. Thus, I included \code{tag_open} and \code{tag_close}. In addition, before opening the stream, an XML declaration \code{<?xml version="1.0"?>} is needed, which uses slightly different syntax to XML tags. Since this syntax does not appear anywhere else, I used a custom parser for this purpose.

These parsers are all implemented in terms of smaller named parsers, combined using the Angstrom parser combinators. For example, I defined \code{tag_open} this way:

\begin{lstlisting}[language=ml]
let tag_open =
  tok_langle *> qual_name >>= fun (ns,id) ->
    lift2 (fun attrs _ -> Raw.Branch ((ns,id,attrs),[]))
      (many attr_val)
      tok_rangle
\end{lstlisting}

This can be read as: ``Accept the token \code{<}, then a qualified name, then zero or more attribute-value pairs, then the token \code{>}; combine the qualified name and the attributes into a \code{Branch} node with no children''. To elaborate: \code{tok_langle = lex (char '<')}, \code{tok_colon = lex (char ':')|, and so on, where \code{lex} skips whitespace.

The parsers written in this manner resemble the Context-Free-Grammars of XML structures, although the choice operator \code{<|>} is an ordered choice. This shows itself in my implementation of \code{tree}:

\begin{lstlisting}[language=ml]
let tree = fix ( fun t_rec ->
  ( tok_langle *> qual_name >>= fun (ns,id) ->
          lift2 (fun attrs children -> Raw.Branch ((ns, id, attrs), children))
            (many attr_val)
            (tok_leaf *> return [] <|> tok_rangle *> branch t_rec (ns,id)) )
  <|> (take_while1 (function | '<' -> false | _ -> true) >>| Raw.text) )
\end{lstlisting}

As an XML node can be simple text, this is accounted for by assuming text content when an attempt to parse a tag fails.

[more on parsers]

\subsection{The \code{Raw} module}
As mentioned, the \code{Raw} module contains the `literal' abstract XML representation that these parsers target. Consider

\begin{lstlisting}[language=xml]
<foo:error type="fatal" xmlns:foo="long-application-namespace" >
  <a></a>
  <b></b>
  Sample text
</foo:error>
\end{lstlisting}

The parent node has a qualified tag \code{foo:error}, along with a list of attributes. Each attribute conceptually consists of a prefix, name and value. The prefix might be empty, such as the case of \code{type="fatal"}. The first task of abstract representation is to make all of these explicit, representing attributes as pairs of qualified names and values. \code{type="fatal"} and \code{xmlns:foo="bar"} become the list
\begin{lstlisting}
[ (("", "type"), "fatal"); (("xmlns", "foo"), "bar") ]
\end{lstlisting}
The above XML source would parse into the following \code{Raw.xml}:

\begin{lstlisting}[language=ml]
Branch ( ("foo", "error", [
    (("", "type"), "fatal");
    (("xmlns", "foo"), "long-application-namespace")
  ]) , [
    Branch ( ("", "a", []) , []) ;
    Branch ( ("", "b", []) , []) ;
    Text "Sample text" ;
] )
\end{lstlisting}

Note the `literal' interpretation of the attribute list as an actual OCaml list. Technically, the order of XML attributes does not matter, but it is simpler to use a list at this level. Also, the special considerations of namespaces and prefixes are not handled at this level; it sees \code{xmlns:foo="bar"} as just another attribute.

The \code{Raw} module provides functions to convert its data structures into strings. The main \code{to_string} function, which recursively serialises an XML tree, is as follows:
